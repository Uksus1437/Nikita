'''Системный администратор раз в неделю создаёт архив пользовательских файлов. 
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов. 
Известно, какой объём занимает файл каждого пользователя.

По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите 
максимальное число пользователей, чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.

Входные данные.

В первой строке входного файла находятся два числа: S  — размер свободного места на диске 
(натуральное число, не превышающее 10 000) и N  — количество пользователей (натуральное число, не превышающее 1000). 
В следующих N строках находятся значения объёмов файлов каждого пользователя (все числа натуральные, 
не превышающие 100), каждое в отдельной строке.

Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив, 
затем максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, 
что сохранены файлы максимально возможного числа пользователей.

Пример входного файла:

100 4
80
30
50
40

30 50 = 80
2 50

При таких исходных данных можно сохранить файлы максимум двух пользователей. 
Возможные объёмы этих двух файлов — 30 и 40, 30 и 50 или 40 и 50. 
Наибольший объём файла из перечисленных пар  — 50, поэтому ответ для приведённого примера:

2 50

8200 970
[30, 40, 50, 80]
'''

f = open('26.txt').readlines()

sp = []

for i in f:
    sp.append(int(i))

s = 8200
k = 970

sp.sort()

ob_s = []

for i in sp:
    if sum(ob_s) + i <= s:
        ob_s.append(i)
    elif sum(ob_s[:-1]) + i <= s:
        del ob_s[-1]
        ob_s.append(i)

print(sum(ob_s), max(ob_s))



'''В магазине для упаковки подарков есть N кубических коробок. 
Самой интересной считается упаковка подарка по принципу матрёшки — подарок упаковывается в одну из коробок, 
та в свою очередь в другую коробку и т. д. Одну коробку можно поместить в другую, 
если длина её стороны хотя бы на 3 единицы меньше длины стороны другой коробки.

Определите наибольшее количество коробок, которое можно использовать для упаковки одного подарка, 
и максимально возможную длину стороны самой маленькой коробки, где будет находиться подарок. 
Размер подарка позволяет поместить его в самую маленькую коробку.

Входные данные.

В первой строке входного файла находится число N — количество коробок в магазине 
(натуральное число, не превышающее 10 000). В следующих N строках находятся значения длин сторон коробок 
(все числа натуральные, не превышающие 10 000), каждое — в отдельной строке.

Запишите в ответе два целых числа: сначала наибольшее количество коробок, 
которое можно использовать для упаковки одного подарка, 
затем максимально возможную длину стороны самой маленькой коробки в таком наборе.

Пример входного файла:

5
43
40
32
40
30

Пример входного файла приведён для пяти коробок и случая, когда минимальная допустимая разница между 
длинами сторон коробок, подходящих для упаковки «матрёшкой», составляет 3 единицы.

При таких исходных данных условию задачи удовлетворяют наборы коробок с длинами сторон 30, 40 и 43 или 32, 
40 и 43 соответственно, то есть количество коробок равно 3, а длина стороны самой маленькой коробки равна 32.
10000
       i
ob = [43, 40, 40, 32, 30]

m = [43]

m[-1] - i >= 3
'''

f=open("26.txt").readlines()
od=[]
for i in f:
    od.append(int(i))
od.sort(reverse=True)
kr = [max(od)]
for o in od:
    if kr[-1] - o >=3:
        kr.append(o)
print(len(kr), min(kr))



'''5
Системный администратор раз в неделю создаёт архив пользовательских файлов. 
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов. 
Известно, какой объём занимает файл каждого пользователя.

По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите 
максимальное число пользователей, чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.

Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив, 
затем максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, 
что сохранены файлы максимально возможного числа пользователей.
S    N
543 2358
'''

f=open("26.txt").readlines()
gt=[]
tg=[]
for i in f:
    gt.append(int(i))

gt.sort()
for n in gt:
    if sum(tg)+n <=543:
        tg.append(n)
print(len(tg), max(tg))



'''В аэропорту есть камера хранения из K ячеек, которые пронумерованы с 1.

Принимаемый багаж кладется в свободную ячейку с минимальным номером. Известно время, 
когда пассажиры сдают и забирают багаж (в минутах с начала суток). 
Ячейка доступна для багажа, начиная со следующей минуты, после окончания срока хранения. 
Если свободных ячеек не находится, то багаж не принимается в камеру хранения.

Найдите количество багажей, которое будет сдано в камеры за 24 часа и номер ячейки, 
в которую сдаст багаж последний пассажир.

Входные данные.

В первой строке входного файла находится число K — 
количество ячеек в камере хранения, во второй строке файла число 
N — количество пассажиров, сдающих багаж (натуральное число, не превышающее 1000). 
Каждая из следующих N строк содержит два натуральных числа, не превышающих 1440: 
время сдачи багажа и время выдачи багажа.

Выходные данные.

Программа должна вывести два числа: количество сданных в камеру хранения багажей и номер ячейки, 
в которую примут багаж у последнего пассажира, который сможет сдать багаж.

[[30, 1000], [60, 100], [61, 1100], [1010, 1440]]

[1000, 100]
'''
f = open('26.txt').readlines()[2:]

k = 210
n = 600
c=0
bags=[]
for i in f:
    b, b1=map(int,i.split())
    bags.append([b, b1])

bags.sort()

places = [0] * k

last_place = 0

for i in range(len(bags)):
    for j in range(len(places)):
        if places[j] == 0:
            places[j] = bags[i][1]
            c+=1
            last_place = j+1
            break
        if bags[i][0] >= places[j]+1:
            places[j] = bags[i][1]
            c+=1
            last_place = j+1
            break

print(c, last_place)

